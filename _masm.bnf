dotcom
  : endOfLine| comment
  ; 
eqDir
  : id  "=" immExpr dotcom
  ; 
addOp
  : "+" | "-"
  ; 
aExpr
  : term | aExpr  "&&" term
  ; 
altId
  : id
  ; 
arbitraryText
  : charList
  ; 
asmInstruction
  : mnemonic  exprList? 
  ; 
assumeDir
  : "ASSUME" assumeList dotcom| "ASSUME NOTHING " dotcom
  ; 
assumeList 
  : assumeRegister| assumeList  ", " assumeRegister
  ; 
assumeReg
  : register  "    : " assumeVal
  ; 
assumeRegister
  : assumeSegReg| assumeReg
  ; 
assumeSegReg
  : segmentRegister  "    : " assumeSegVal
  ; 
assumeSegVal
  : frameExpr| "NOTHING" | "ERROR"
  ; 
assumeVal
  : qualifiedType| "NOTHING" | "ERROR"
  ; 
bcdConst
  :  sign?  decNumber
  ; 
binaryOp
  : "== "| "!= "| ">= "| "<= "| "> "| "< "| "&" 
  ; 
eqconstExpr
  : "=" constExpr
  ;
bitDef
  : bitFieldId  ":"  bitFieldSize eqconstExpr?
  ; 
bitDefList
  : bitDef| bitDefList  ", " dotcom?  bitDef
  ; 
bitFieldId 
  : id 
  ; 
bitFieldSize
  : constExpr
  ; 
ifcexpr
  : ".IF" cExpr
  ;
blockStatements
  : directiveList| ".CONTINUE" ifcexpr? | ".BREAK " ifcexpr?
  ; 
bool
  : "TRUE | FALSE"
  ; 
byteRegister
  : AL | AH | BL | BH | CL | CH | DL | DH 
  ; 
cExpr
  : aExpr| cExpr  ":" aExpr
  ; 
character
  : Any character with ordinal in the range 0–255 except linefeed (10)
  ; 
charList
  : character| charList character
  ; 
className
  : string
  ; 
commDecl
  :  nearfar?   langType?  id ":" commType eqconstExpr?
  ; 
commDir
  : "COMM " commList dotcom
  ; 
comment
  : "  ; " text dotcom
  ; 
commentDir
  : "COMMENT" delimitertext text delimiter text dotcom
  ; 
commList
  : commDecl| commList  ", " commDecl
  ; 
commType
  : type| constExpr
  ; 
constant
  : digits  radixOverride? 
  ; 
constExpr
  : expr
  ; 
contextDir
  : "PUSHCONTEXT " contextItemList dotcom| "POPCONTEXT " contextItemList dotcom
  ; 
contextItem
  : "ASSUMES "| "RADIX "| "LISTING "| "CPU "| "ALL"
  ; 
contextItemList
  : contextItem| contextItemList  ", " contextItem
  ; 
controlBlock
  : whileBlock| repeatBlock
  ; 
controlDir
  : controlIf| controlBlock
  ; 
controlElseif
  : ".ELSEIF" cExpr dotcom directiveList controlElseif? 
  ; 

elsedirectiveList
  : ".ELSE" dotcom directiveList
  ;
controlIf
  : ".IF " cExpr dotcom directiveList controlElseif? elsedirectiveList? ".ENDIF " dotcom
  ; 
coprocessor
  : ".8087 "| ".287" | ".387" | ".NO87"
  ; 
crefDir
  : crefOption dotcom
  ; 
crefOption
  : ".CREF"| ".XCREF " idList? | ".NOCREF " idList? 
  ; 
cxzExpr
  : expr| "! " expr| expr  "== " expr| expr  "!= " expr
  ; 
dataDecl
  : "DB" | "DW" | "DD" | "DF" | "DQ" | "DT" | dataType | typeId
  ; 
dataDir
  :  id?  dataItem dotcom
  ; 
dataItem
  : dataDecl scalarInstList| structTag structInstList| typeId structInstList| unionTag structInstList| recordTag recordInstList
  ; 
dataType
  : "BYTE "| "SBYTE "| "WORD "| "SWORD "| "DWORD "| "SDWORD" | "FWORD "| "QWORD "| "TBYTE"| "REAL4" | "REAL8 "| "REAL10 "
  ; 
decdigit
  : 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9
  ; 
decNumber
  : decdigit| decNumber decdigit
  ; 
delimiter
  : Any character except whiteSpaceCharacter
  ; 
digits
  : decdigit| digits decdigit| digits hexdigit
  ; 
directive
  : generalDir| segmentDef
  ; 
directiveList
  : directive| directiveList directive
  ; 
distance
  : nearfar| "NEAR16 "| "NEAR32 "| "FAR16 "| "FAR32 "
  ; 
e01
  : e01 orOp e02| e02
  ; 
e02
  : e02  "AND " e03| e03
  ; 
e03
  : "NOT " e04| e04
  ; 
e04
  : e04 relOp e05| e05
  ; 
e05
  : e05 addOp e06| e06
  ; 
e06
  : e06 mulOp e07| e06 shiftOp e07| e07
  ; 
e07
  : e07 addOp e08| e08
  ; 
e08
  : "HIGH " e09| "LOW " e09| "HIGHWORD " e09| "LOWWORD " e09| e09
  ; 
e09
  : "OFFSET " e10| "SEG " e10| "LROFFSET " e10| "TYPE " e10| "THIS " e10| e09  "PTR " e10| e09 "     : " e10| e10
  ; 
e10
  : e10  ". " e11| e10  expr? | e11
  ; 
e11
  : "( " expr  ")"|  expr? | "WIDTH " id| "MASK " id| "SIZE " sizeArg| "SIZEOF " sizeArg| "LENGTH " id| "LENGTHOF" id | recordConst| string| constant| type| id| "$"| segmentRegister| register| "ST"| "ST ( " expr " )"
  ; 
echoDir
  : "ECHO" arbitraryText dotcom "%OUT" arbitraryText dotcom
  ; 
elseifBlock
  : elseifStatement dotcom directiveList elseifBlock? 
  ; 
elseifStatement
  : "ELSEIF " constExpr| "ELSEIFE " constExpr| "ELSEIFB " textItem| "ELSEIFNB " textItem | "ELSEIFDEF " id| "ELSEIFNDEF " id| "ELSEIFDIF " textItem " , " textItem| "ELSEIFDIFI " textItem " , " textItem| "ELSEIFIDN " textItem " , " textItem| "ELSEIFIDNI " textItem " , " textItem| "ELSEIF1"| "ELSEIF2"
  ; 
endDir
  : "END"  immExpr?  dotcom
  ; 
endpDir
  : procId "ENDP " dotcom
  ; 
endsDir
  : id "ENDS " dotcom
  ; 
equDir
  : textMacroId  "EQU " equType dotcom
  ; 
equType
  : immExpr| textLiteral
  ; 
errorDir
  : errorOpt dotcom
  ; 
errorOpt
  : ".ERR"  textItem? | ".ERRE " constExpr " " optText? | ".ERRNZ " constExpr " " optText? | ".ERRB " textItem " " optText? | ".ERRNB " textItem " " optText? | ".ERRDEF " id  optText? | ".ERRNDEF " id " " optText? | ".ERRDIF " textItem  ", " textItem  optText? | ".ERRDIFI " textItem  ", " textItem  optText? | ".ERRIDN " textItem  ", " textItem  optText? | ".ERRIDNI " textItem  ", " textItem  optText? | ".ERR1 " textItem? | ".ERR2 " textItem?  
  ; 
exitDir
  : ".EXIT " expr?  dotcom
  ; 
exitmDir    :
  : "EXITM"| "EXITM " textItem
  ; 
exponent
  : E  sign?  decNumber
  ; 
expr
  : "SHORT " e05| ".TYPE " e01| "OPATTR " e01| e01
  ; 
exprList
  : expr| exprList  ","  expr
  ; 
altId
  : "(" altId ")"
  ;
externDef
  :  langType?  id altId? "    : " externType
  ; 
externDir
  : externKey externList dotcom
  ; 
externKey
  : "EXTRN "| "EXTERN "| "EXTERNDEF"
  ; 
externList
  : externDef| externList  ", " dotcom?  externDef
  ; 
externType
  : "ABS"| qualifiedType
  ; 
fieldAlign
  : constExpr
  ; 
fieldInit
  :  initValue? | structInstance
  ; 
fieldInitList
  : fieldInit| fieldInitList ","  dotcom?  fieldInit
  ; 
fileChar
  : delimiter
  ; 
fileCharList
  : fileChar| fileCharList fileChar
  ; 
fileSpec
  : fileCharList| textLiteral
  ; 
flagName
  : "ZERO? "| "CARRY?" | "OVERFLOW?"|" SIGN? "| "PARITY? "
  ; 
floatNumber 
  :  sign?  decNumber "."  decNumber?   exponent? | digits R| digits r
  ; 
forcDir
  : "FORC" | "IRPC"
  ; 
forDir
  : "FOR" |" IRP"
  ; 
dotdotforParmType
  : ":" forParmType
  ;
forParm
  : id dotdotforParmType?
  ; 
forParmType
  : "REQ"| "= " textLiteral
  ; 
frameExpr
  : "SEG " id | DGROUP "    : " id| segmentRegister  "    : " id| id
  ; 
generalDir
  : modelDir | segOrderDir | nameDir| includeLibDir | commentDir| groupDir | assumeDir| structDir | recordDir | typedefDir| externDir | publicDir | commDir | protoTypeDir| equDir | eqDir | textDir| contextDir | optionDir | processorDir| radixDir | titleDir | pageDir | listDir | crefDir | echoDir| ifDir | errorDir | includeDir | macroDir | macroCall | macroRepeat | purgeDir| macroWhile | macroFor | macroForc| aliasDir
  ; 
gpRegister
  : AX | EAX | BX | EBX | CX | ECX | DX | EDX| BP | EBP | SP | ESP | DI | EDI | SI | ESI
  ; 
groupDir 
  : groupId  "GROUP " segIdList
  ; 
groupId
  : id
  ; 
hexdigit
  : a | b | c | d | e | f| A | B | C | D | E | F
  ; 
id
  : alpha| id alpha| id decdigit
  ; 
idList
  : id| idList "," id
  ; 
elsedirectiveList
  : "ELSE" dotcom directiveList
  ;
ifDir
  : ifStatement dotcom directiveList elseifBlock? elsedirectiveList? "ENDIF " dotcom
  ; 
ifStatement
  : "IF " constExpr| "IFE " constExpr| "IFB " textItem| "IFNB " textItem| "IFDEF " id| "IFNDEF " id| "IFDIF " textItem ", " textItem| "IFDIFI " textItem , textItem| "IFIDN " textItem , textItem| "IFIDNI " textItem , textItem| "IF1"| "IF2"
  ; 
immExpr
  : expr
  ; 
includeDir
  : "INCLUDE " fileSpec dotcom
  ; 
includeLibDir
  : "INCLUDELIB " fileSpec dotcom
  ; 
initValue
  : immExpr| string| "?"| constExpr  "DUP ( " scalarInstList" )"| floatNumber| bcdConst
  ; 
inSegDir
  :  labelDef?  inSegmentDir
  ; 
inSegDirList
  : inSegDir | inSegDirList inSegDir
  ; 
inSegmentDir
  : instruction| dataDir| controlDir| startupDir| exitDir| offsetDir| labelDir| procDir  localDirList?   inSegDirList?  endpDir| invokeDir| generalDir 
  ; 
instrPrefix
  : "REP "| "REPE" | "REPZ" | "REPNE" | "REPNZ" | "LOCK"
  ; 
instruction
  :  instrPrefix?  asmInstruction
  ; 
invokeArg
  : register  "::" register| expr| "ADDR" expr
  ; 
commainvokeList
  : "," dotcom? invokeList
  ;
invokeDir
  : "INVOKE " expr commainvokeList? dotcom
  ; 
invokeList
  : invokeArg| invokeList  "," dotcom?  invokeArg
  ; 
keyword
  : Any reserved word
  ; 
keywordList
  : keyword | keyword keywordList
  ; 
labelDef
  : id  ":"| id  "::"| "@@:"
  ; 
labelDir
  : id  "LABEL " qualifiedType dotcom
  ; 
langType
  : "C" | "PASCAL" | "FORTRAN" |" BASIC" | "SYSCALL" | "STDCALL"
  ; 
listDir
  : listOption dotcom
  ; 
listOption
  : ".LIST"| ".NOLIST "| ".XLIST"| ".LISTALL"| ".LISTIF "| ".LFCOND"| ".NOLISTIF" | ".SFCOND"| ".TFCOND"| ".LISTMACROALL "| ".LALL"| ".NOLISTMACRO "| ".SALL"| ".LISTMACRO" | ".XALL"
  ; 
localDef
  : "LOCAL " idList dotcom
  ; 
localDir
  : "LOCAL " parmList dotcom
  ; 
localDirList
  : localDir| localDirList localDir
  ; 
localList
  : localDef| localList localDef
  ; 
macroArg
  : "% " constExpr| "% " textMacroId| "%" macroFuncId "(" macroArgList " )"| string| arbitraryText| "<" arbitraryText ">"
  ; 
macroArgList
  : macroArg| macroArgList  ", " macroArg
  ; 
macroBody
  :  localList? macroStmtList
  ; 
macroCall
  : id macroArgList dotcom| id  "( " macroArgList  ")"
  ; 
macroDir
  : id  "MACRO " macroParmList?  dotcom macroBody "ENDM " dotcom
  ; 
macroFor
  : forDir forParm  "," "<" macroArgList  ">"  dotcom macroBody "ENDM " dotcom
  ; 
macroForc
  : forcDir id  "," textLiteral dotcom macroBody "ENDM" dotcom
  ; 
macroFuncId
  : id
  ; 
macroId
  : macroProcId| macroFuncId
  ; 
macroIdList
  : macroId| macroIdList  ","  macroId
  ; 
macroLabel
  : id
  ; 
dotdotparmType
  : ":" parmType
  ;
macroParm
  : id dotdotparmType?
  ; 
macroParmList
  : macroParm| macroParmList  ", " dotcom?  macroParm
  ; 
macroProcId
  : id
  ; 
macroRepeat
  : repeatDir constExpr dotcom macroBody "ENDM " dotcom
  ; 
macroStmt
  : directive| exitmDir| ":" macroLabel| "GOTO " macroLabel
  ; 
macroStmtList
  : macroStmt dotcom| macroStmtList macroStmt dotcom
  ; 
macroWhile
  : "WHILE " constExpr dotcom macroBody "ENDM " dotcom
  ; 
mapType
  : "ALL "| "NONE "| "NOTPUBLIC"
  ; 
memOption
  : "TINY "| "SMALL "| "MEDIUM "| "COMPACT "| "LARGE "| "HUGE "| "FLAT" 
  ; 
mnemonic
  : Instruction name
  ; 
commamodelOptlist
  : "," modelOptlist
  ;
modelDir
  : ".MODEL " memOption commamodelOptlist? dotcom
  ; 
modelOpt
  : langType| stackOption 
  ; 
modelOptlist
  : modelOpt| modelOptlist  ", " modelOpt
  ; 
module
  :  directiveList?  endDir
  ; 
mulOp
  : "* "| "/" | "MOD"
  ; 
nameDir
  : "NAME" id dotcom
  ; 
nearfar
  : "NEAR "| "FAR"
  ; 
nestedStruct
  : structHdr  id?  dotcom structBody "ENDS " dotcom
  ; 
offsetDir
  : offsetDirType dotcom
  ; 
offsetDirType
  : "EVEN"| "ORG " immExpr| "ALIGN " constExpr? 
  ; 
offsetType
  : "GROUP" | "SEGMENT "| "FLAT"
  ; 
oldRecordFieldList
  :  constExpr? | oldRecordFieldList ","  constExpr? 
  ; 
optionDir
  : "OPTION " optionList dotcom
  ; 
optionItem
  : "CASEMAP     : " mapType| "DOTNAME "| "NODOTNAME"| "EMULATOR" | "NOEMULATOR"| "EPILOGUE     : " macroId| "EXPR16" | "EXPR32"| "LANGUAGE     : " langType| "LJMP" | "NOLJMP"| "M510 "| "NOM510"| "NOKEYWORD" "    : <" keywordList ">"| "NOSIGNEXTEND"| "OFFSET     : " offsetType| "OLDMACROS" | "NOOLDMACROS"| "OLDSTRUCTS" | "NOOLDSTRUCTS"| "PROC     : " oVisibility| "PROLOGUE     : " macroId| "READONLY "| "NOREADONLY"| "SCOPED" | "NOSCOPED"| "SEGMENT     : " segSize| "SETIF2     : " bool
  ; 
optionList
  : optionItem| optionList  ", " dotcom?  optionItem
  ; 
optText
  : ", " textItem
  ; 
orOp
  : "OR "| "XOR"
  ; 
oVisibility
  : "PUBLIC" |" PRIVATE" |" EXPORT"
  ; 
pageDir
  : "PAGE " pageExpr?  dotcom
  ; 
commapageWidth
  : "," pageWidth
  ;
pageExpr
  : "+"|  pageLength?  commapageWidth?
  ; 
pageLength
  : constExpr
  ; 
pageWidth
  : constExpr
  ; 
dotdotqualifiedType
  : ":" qualifiedType
  ;
parm
  : parmId dotdotqualifiedType? | parmId  constExpr? dotdotqualifiedType?
  ; 
parmId
  : id
  ; 
parmList
  : parm| parmList  ", " dotcom?  parm
  ; 
parmType
  : "REQ"| "= " textLiteral| "VARARG"
  ; 
pOptions
  :  distance?   langType?   oVisibility? 
  ; 
primary
  : expr binaryOp expr| flagName| expr
  ; 
brmacroArgList
  : "<" macroArgList ">"
  ;
procDir
  : procId  "PROC " pOptions?  brmacroArgList?  usesRegs?   procParmList? 
  ; 
processor
  : ".8086"| ".186"| ".286 "| ".286C "| ".286P"| ".386 "| ".386C "| ".386P"| ".486 "|" .486P" | ".586"| ".586P" |
    ".686" | ".686P" | ".K3D" | ".MMX" | ".XMM" | ".8086"
  ; 
processorDir
  : processor dotcom | coprocessor dotcom
  ; 
procId
  : id
  ; 
commaparmList
  : ","  dotcom?  parmList
  ;
commaparmIdvararg
  : ","  dotcom?  parmId ":VARARG"
  ;
procParmList
  : commaparmList? 
    commaparmIdvararg?
  ; 
protoArg 
  :  id?  ":" qualifiedType 
  ; 
commaprotoList
  : ","  dotcom?  protoList
  ;
commaidvararg
  : ","  dotcom?   id?  ":VARARG"
  ;
protoArgList
  : commaprotoList?
    commaidvararg?
  ; 
protoList
  : protoArg| protoList  "," dotcom?  protoArg
  ; 
protoSpec
  :  distance?   langType?   protoArgList?  | typeId
  ; 
protoTypeDir
  : id  "PROTO " protoSpec
  ; 
pubDef
  :  langType?  id
  ; 
publicDir
  : "PUBLIC " pubList dotcom
  ; 
pubList
  : pubDef| pubList  "," dotcom?  pubDef
  ; 
purgeDir
  : "PURGE " macroIdList
  ; 
qualifiedType
  : type|  distance?  "PTR"  qualifiedType? 
  ; 
qualifier
  : qualifiedType| "PROTO" protoSpec
  ; 
quote
  : '"' | "'"
  ; 
radixDir
  : ".RADIX" constExpr dotcom
  ; 
radixOverride
  : h | o | q | t | y | H | O | Q | T | Y
  ; 
recordConst
  : recordTag "{ " oldRecordFieldList "}"| recordTag "<" oldRecordFieldList ">"
  ; 
recordDir
  : recordTag  "RECORD " bitDefList dotcom 
  ; 
recordFieldList
  :  constExpr? | recordFieldList  ","  dotcom?   constExpr? 
  ; 
recordInstance
  : "{"  dotcom?  recordFieldList  dotcom?  "}"| "<" oldRecordFieldList ">"| constExpr "DUP (" recordInstance ")"
  ; 
recordInstList
  : recordInstance| recordInstList ","  dotcom?  recordInstance
  ; 
recordTag
  : id
  ; 
register
  : specialRegister| gpRegister| byteRegister
  ; 
regList
  : register| regList register
  ; 
relOp
  : "EQ "| "NE "| "LT "| "LE "| "GT "| "GE"
  ; 
repeatBlock
  : ".REPEAT" dotcom blockStatements dotcom untilDir dotcom
  ; 
repeatDir
  : "REPEAT" | "REPT"
  ; 
scalarInstList
  : initValue| scalarInstList  ","  dotcom?  initValue
  ; 
segAlign
  : "BYTE "| "WORD "| "DWORD "| "PARA" | "PAGE"
  ; 
segAttrib
  : "PUBLIC"| "STACK"| "COMMON"| "MEMORY"| "AT " constExpr| "PRIVATE"
  ; 
segDir
  : ".CODE " segId? | ".DATA"| ".DATA?"| ".CONST"| ".FARDATA " segId? | ".FARDATA? " segId? | ".STACK " constExpr? 
  ; 
segId
  : id
  ; 
segIdList 
  : segId| segIdList  ", " segId
  ; 
segmentDef
  : segmentDir  inSegDirList?  endsDir| simpleSegDir  inSegDirList?   endsDir? 
  ; 
segmentDir
  : segId  "SEGMENT"  segOptionList?  dotcom
  ; 
segmentRegister
  : CS | DS | ES | FS | GS | SS
  ; 
segOption
  : segAlign| segRO| segAttrib| segSize| className
  ; 
segOptionList
  : segOption| segOptionList segOption
  ; 
segOrderDir
  : ".ALPHA "| ".SEQ" | ".DOSSEG" | "DOSSEG"
  ; 
segRO
  : "READONLY"
  ; 
segSize 
  : "USE16" | "USE32 "|" FLAT"
  ; 
shiftOp
  : "SHR "| "SHL"
  ; 
sign
  : "-" | "+"
  ; 
simpleExpr
  : "( " cExpr  ")"| primary
  ; 
simpleSegDir
  : segDir dotcom
  ; 
sizeArg
  : id| type| e10
  ; 
specialChars
  : "    :" | "." | "[[" | "]]" | "(" | ")" | "<" | ">" | "{" | "}"| "+" | "-" | "/" | "*" | "&" | "%" | "!"| "'" | "\" | "=" | "  ;" | "," | '"'| whiteSpaceCharacter | endOfLine
  ; 
specialRegister
  : CR0 | CR2 | CR3 | DR0 | DR1 | DR2 | DR3 | DR6 | DR7| TR3 | TR4 | TR5 | TR6 | TR7
  ; 
stackOption
  : "NEARSTACK" | "FARSTACK" 
  ; 
startupDir
  : ".STARTUP "dotcom
  ; 
stext
  : stringChar| stext stringChar
  ; 
string
  : quote  stext?  quote
  ; 
stringChar
  : quote quote| Any character except quote
  ; 
structBody
  : structItem dotcom | structBody structItem dotcom
  ; 
commanonuniq
  : "," "NONUNIQUE"
  ;
structDir
  : structTag structHdr  fieldAlign?  commanonuniq? dotcom structBody structTag  "ENDS " dotcom
  ; 
structHdr
  : "STRUC "| "STRUCT "| "UNION "
  ; 
structInstance
  : "<"  fieldInitList?  ">"| "{" dotcom?   fieldInitList?   dotcom?  "}"| constExpr "DUP" "(" structInstList ")"
  ; 
structInstList
  : structInstance| structInstList  ","  dotcom?  structInstance
  ; 
structItem 
  : dataDir| generalDir| offsetDir| nestedStruct
  ; 
structTag
  : id
  ; 
term
  : simpleExpr| "!" simpleExpr
  ; 
text
  : textLiteral| text character| "! " character text| character| "! " character
  ; 
textDir
  : id textMacroDir dotcom
  ; 
textItem
  : textLiteral| textMacroId| "%" constExpr
  ; 
textLen
  : constExpr
  ; 
textList
  : textItem| textList  "," dotcom?  textItem
  ; 
textLiteral
  : "<" text ">" dotcom
  ; 
commatextLen
  : "," textLen
  ;
textStartcomma
  : textStart  ","
  ;
textMacroDir
  : "CATSTR" textList? | "TEXTEQU" textList? | "SIZESTR" textItem| "SUBSTR" textItem  "," textStart commatextLen| "INSTR " textStartcomma? textItem  "," textItem
  ; 
textMacroId
  : id
  ; 
textStart
  : constExpr
  ; 
titleDir
  : titleType arbitraryText dotcom
  ; 
titleType
  : "TITLE" | "SUBTITLE"| "SUBTTL"
  ; 
type
  : structTag| unionTag| recordTag| distance| dataType| typeId
  ; 
typedefDir
  : typeId  "TYPEDEF" qualifier
  ; 
typeId
  : id
  ; 
unionTag
  : id
  ; 
untilDir
  : ".UNTIL" cExpr dotcom ".UNTILCXZ" cxzExpr?  dotcom
  ; 
usesRegs
  : "USES" regList 
  ; 
whileBlock
  : ".WHILE" cExpr dotcom blockStatements dotcom ".ENDW"
  ; 
whiteSpaceCharacter
  : ASCII 8, 9, 11–13, 26, 32  ;
